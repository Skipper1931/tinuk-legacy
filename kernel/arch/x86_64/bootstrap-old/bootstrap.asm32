BITS 32

SECTION .bss
resb 4096
stack_top:

SECTION .rodata
gdt64:
    dq 0
.code: equ $ - gdt64
    dq (1<<44) | (1<<47) | (1<<41) | (1<<43) | (1<<53)
.data: equ $ - gdt64
    dq (1<<44) | (1<<47) | (1<<41)
.pointer:
    dw .pointer - gdt64 - 1
    dq gdt64

SECTION .text
GLOBAL _start32
GLOBAL asm_hang
GLOBAL enable_paging
EXTERN check_64
EXTERN bootmain
EXTERN ptl4
_start32:
    cli
    mov esp, stack_top
    mov ebp, esp
    push eax
    push ebx

    call check_64
    push eax

    call bootmain

enable_paging:
    ; move page table address to cr3
    mov eax, ptl4
    mov cr3, eax
    mov edi, [eax + 4]
    or edi, 0b11

    ; enable PAE
    mov eax, cr4
    or eax, 1 << 5
    mov cr4, eax

    ; set the long mode bit
    mov ecx, 0xC0000080
    rdmsr
    or eax, 1 << 8
    wrmsr

    ; enable paging
    mov eax, cr0
    or eax, 1 << 31
    or eax, 1 << 16
    mov cr0, eax

    ret
    
    %ifdef COMMENT
    lgdt [gdt64.pointer]
    mov ax, gdt64.data
    mov ss, ax
    mov ds, ax
    mov es, ax

    jmp gdt64.code:trampoline_to_64 ; we need to jmp to 64-bit address while still in 32-bit mode, so instead we jump into a 32-bit address,
                                    ; which'll run in long mode, that will trampoline us to the real _start64
    %endif
asm_hang:
    cli
.lp:hlt
    jmp .lp